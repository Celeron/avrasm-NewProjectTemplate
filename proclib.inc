.IFNDEF	_PROCLIB__INCLUDED_
.EQU	_PROCLIB__INCLUDED_ = 1
.MESSAGE "Note: <proclib.inc> (ver.0.1 beta) have included!" 
;=== BEGIN "proclib.inc" ===================================================
; Библиотека Подпрограмм общего назначения


; Внимание! В отличие от кода Макросов, Код Подпрограмм из данной библиотеки - 
; всегда и полностью, ВКЛЮЧАЕТСЯ В СЕГМЕНТ КОДА программы - т.е. занимает место! 
; Поэтому, в данном файле должны быть включены только те процедуры, которые реально используются!
; (Остальные - следует /*... закомментировать ...*/)


; Рекомендации по использованию "индексных регистров":
; 	* РОН из диапазона R26..R31 лучше не использовать для иных нужд, чем как "индексные регистры" (т.е. не рекомендуется использовать их в качестве "временных переменных").
; 	При реализации алгоритма функции, в коде, часто удобно использовать инструкции "непрямой пересылки данных": LD/ST, LDD/STD.
; 	Возникает вопрос выбора: какие при этом лучше использовать "индексные регистры": X, Y, или Z ?
; 	* Регистр Z лучше не использовать для арифметических преобразований, особенно для "параметров функций" - потому что он требуется для инструкций "непрямого перехода" ICALL/IJMP (дальнобойностью до 64K слов), т.е. Z требуется для вызова самой функции. 	(Напомню, что в семействе МК "ATTiny*" нет инструкций "дальнего перехода" CALL/JMP - поэтому, в них, инструкции ICALL/IJMP становятся единственной возможностью!)
; 	* А выбирая между X и Y - в первую очередь, лучше использовать Y, т.к. он более функционален: поддерживает также инструкции LDD/STD. 	(Кроме того, Y - чуть ближе к концу файла РОН, что "концептуальнее": меньше вероятность задействования его, в качестве "временного регистра".)


;---------------------------------------------------------------------------

; Примечание: 
;	В коде данной библиотеки, и при работе с ней, регистры R16,R17,R18,R19
;	рекомендуется использовать как "временные переменные" - поэтому, 
;	в вашем прикладном коде, не используйте их для хранения постоянных данных!
; Как сказал DI HALT: 
;	Регистры можно предварительно затолкать в стек, но я дам тебе лучше другой совет: 
;	когда пишешь программу, продумывай алгоритм так, чтобы использовать регистры 
;	как сплошной TEMP, данные которого актуальны только здесь и сейчас.
;	И что будет с ними в следующей процедуре - уже не важно. 
;	А все перманентные данные - следует сохранять в оперативке (SRAM).

; Совет: вы также можете использовать эти псевдонимы регистров в своей программе:
.def	temp	= R16
.def	temp1	= R16
.def	temp2	= R17
.def	temp3	= R18
;.def	temp4	= R19	; пока не используется данной библиотекой

;---------------------------------------------------------------------------




;***************************************************************************
;*
;*  Запись / Чтение памяти EEPROM
;*
;***************************************************************************


;---------------------------------------------------------------------------
;
; Записать байт данных в память EEPROM 
; (Supported: ATMega16, ATTiny25/45/85)
;
; Описание: см. http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-eeprom.html
; Пример вызова:
;	LDI 	EepromAddressLow,  0	; Загружаем адрес нулевой ячейки EEPROM
;	LDI 	EepromAddressHigh, 0	;  
;	LDI 	EepromDataByte,    45	; и хотим записать в нее число 45
;	RCALL 	EEPROM_WRITE 		; вызываем процедуру записи.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

.def	EepromDataByte		= R22
.def	EepromAddressLow 	= R23
.def	EepromAddressHigh 	= R24

; Памятка: также использует/портит содержимое регистра TEMP.

;----- Code 


; ВАЖНО!!! Если вызываете данную процедуру из обработчика прерывания (в котором прерывания уже запрещены) - тогда в коде процедуры следует закомментировать строки с CLI/SEI !
; Для этого достаточно выключить (закомментировать) определение следующего символа EEPROM_PROC_HANDLE_INTERRUPTS:
;
;.EQU	EEPROM_PROC_HANDLE_INTERRUPTS = 1	; (рекомендуется: закомментировать этот символ!)
;
; 	Лирическое отступление: 
;	Примечание: "Критическими" - здесь являются общие ресурсы ("РОН"), разделяемые разными участками кода ("секциями") под временные переменные нужды...
;	Однако, в общем, управлять прерываниями должна вызывающая программа (в т.ч. и критические секции экранировать CLI/SEI), а не эта вызываемая процедура.
; 	Равно как и множество других вызываемых вспомогательных процедур производят манипуляции с регистрами (и критические секции в них встречаются на каждом шагу) - все ситуации в них не предусмотришь, не заэкранируешь!
; 	А в данной процедуре: критическая секция обозначена только потому, что это будет очень деструктивная ошибка, если она произойдёт - испортится содержимое служебных данных в памяти EEPROM (после чего, зачастую, МК надо нести на программатор, восстанавливать).
; 	Поэтому, если вам понадобилось здесь включить эту директиву - то, вероятно, у вас большие проблемы с архитектурой программы? Оставьте это лучше закомментированным, здесь...


	; Одни и те же вещи, под разными именами, в разных моделях:
	#if defined(__ATtiny25__) || defined(__ATtiny45__) || defined(__ATtiny85__)
		.equ	EepromWriteEnableBit = EEPE;
		.equ	EepromMasterWriteEnableBit = EEMPE;
	#elif defined (__ATmega16__) || defined (__ATmega16A__)
		.equ	EepromWriteEnableBit = EEWE;
		.equ	EepromMasterWriteEnableBit = EEMWE;
	#endif


EEPROM_WRITE:	
		SBIC	EECR,	EepromWriteEnableBit	; Ждем готовности памяти к записи:
		RJMP	EEPROM_WRITE			; крутимся в цикле до тех пор, пока не очистится флаг...
 
	.ifdef EEPROM_PROC_HANDLE_INTERRUPTS
		;=== начало критической секции:
		CLI					; запрещаем прерывания	(!не используйте внутри обработчика прерывания!)
	.endif

	#if defined(__ATtiny25__) || defined(__ATtiny45__) || defined(__ATtiny85__)
		LDI	temp,	(0<<EEPM1)|(0<<EEPM0)	; Set Programming mode = "Atomic Byte Programming" (erase + write)
		OUT	EECR,	temp			; (Note: If the EEPMn bits are zero, writing EEPE (within four cycles after EEMPE is written) will trigger the erase/write operation. Both the erase and write cycle are done...)
	#endif

		OUT 	EEARL,	EepromAddressLow 	; Загружаем адрес нужной ячейки: его старший и младший байты
		OUT 	EEARH,	EepromAddressHigh 	; 
		OUT 	EEDR,	EepromDataByte 		; и сами данные, которые нам нужно записать

		SBI 	EECR,	EepromMasterWriteEnableBit	; взводим предохранитель
		SBI 	EECR,	EepromWriteEnableBit		; стартуем запись байта	(Note: bit remains set until the erase and write opera-tions are completed)
 
	.ifdef EEPROM_PROC_HANDLE_INTERRUPTS
		SEI 					; разрешаем прерывания	(!не используйте внутри обработчика прерывания!)
		;=== конец критической секции
	.endif

		RET 					; возврат из процедуры



;---------------------------------------------------------------------------
;
; Прочитать байт данных из памяти EEPROM
; (Supported: ATMega16, ATTiny25/45/85)
;
; Описание: см. http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-eeprom.html
; Пример вызова:
;	LDI 	EepromAddressLow,0	; Загружаем адрес нулевой ячейки
;	LDI 	EepromAddressHigh,0	; EEPROM из которой хотим прочитать байт
;	RCALL 	EEPROM_READ		; вызываем процедуру чтения. После которой 
;					; в EepromDataByte будет считанный байт.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

;.def	EepromDataByte		= см.выше
;.def	EepromAddressLow 	= см.выше
;.def	EepromAddressHigh 	= см.выше

;----- Code
 
EEPROM_READ:	
		SBIC 	EECR,	EepromWriteEnableBit	; Ждем пока будет завершена прошлая запись:
		RJMP	EEPROM_READ			; крутимся в цикле до тех пор, пока не очистится флаг...

		OUT 	EEARL,	EepromAddressLow	; загружаем адрес нужной ячейки:
		OUT  	EEARH,	EepromAddressHigh	; его старший и младший байты

		SBI 	EECR,	EERE 		; стартуем чтение байта
		IN 	EepromDataByte, EEDR 	; Забираем из регистра данных результат

		RET



;---------------------------------------------------------------------------
;
; Агрегатные процедуры, которые позволяют перекачать сразу массив байтов:
;
; EEPROM_WRITE_SEQUENCE (from SRAM to EEPROM) - записать массив байт из ОЗУ в энергонезависимую память EEPROM.
; EEPROM_READ_SEQUENCE  (from EEPROM to SRAM) - прочитать массив байт из энергонезависимой памяти EEPROM в ОЗУ.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

;.def	EepromAddressLow 	= см.выше	; Начало массива в EEPROM-памяти
;.def	EepromAddressHigh 	= см.выше	;
.def	SramAddressLow 		= R28	; YL	; Начало массива в SRAM-памяти
.def	SramAddressHigh 	= R29	; YH	; 
.def	PumpBytesCount		= R25		; Количество байт, которое скопировать (размер массива)

; Памятка: также использует/портит содержимое регистров TEMP и EepromDataByte (опосредованно).

;----- Code 

EEPROM_WRITE_SEQUENCE:
		TST	PumpBytesCount			; Проверка на дурака: если счётчик уже нулевой?
		BREQ	EXIT__EEPROM_WRITE_SEQUENCE

	LOOP__EEPROM_WRITE_SEQUENCE:
		LD	EepromDataByte,	Y+		; Читаем один байт из SRAM и Инкрементируем адрес SramAddress*
		RCALL	EEPROM_WRITE			; Сохраняем его в EEPROM, по адресу EepromAddress*
		SUBI	EepromAddressLow, (-1)		; Инкрементируем также адрес EepromAddress*
		SBCI	EepromAddressHigh,(-1)
		DEC	PumpBytesCount			; Декрементируем счётчик "количества байт, которое скопировать"
		BRNE	LOOP__EEPROM_WRITE_SEQUENCE	; продолжать, пока не станет ноль в счётчике
	EXIT__EEPROM_WRITE_SEQUENCE:
		RET


;----- Code 

EEPROM_READ_SEQUENCE:
		TST	PumpBytesCount			; Проверка на дурака: если счётчик уже нулевой?
		BREQ	EXIT__EEPROM_READ_SEQUENCE

	LOOP__EEPROM_READ_SEQUENCE:
		RCALL	EEPROM_READ			; Читаем один байт из EEPROM, по адресу EepromAddress*
		ST	Y+,	EepromDataByte		; Сохраняем его в SRAM и Инкрементируем адрес SramAddress*
		SUBI	EepromAddressLow, (-1)		; Инкрементируем также адрес EepromAddress*
		SBCI	EepromAddressHigh,(-1)
		DEC	PumpBytesCount			; Декрементируем счётчик "количества байт, которое скопировать"
		BRNE	LOOP__EEPROM_READ_SEQUENCE	; продолжать, пока не станет ноль в счётчике
	EXIT__EEPROM_READ_SEQUENCE:
		RET



;***************************************************************************
;*
;*  Другие сервисные...
;*
;***************************************************************************


;---------------------------------------------------------------------------
;
; Процедура "тупой задержки" (крутит цикл в CPU)
;
; Величина задержки задаётся 3х байтовым ЧИСЛОм:
;	Через регистровые параметры: TEMP1, TEMP2, TEMP3.
;	Или, как вариант, фиксирована константно, через макроопределения.
;
; Итоговая задержка: 
; 	Количество тактов CPU, которое тупить = (ЧИСЛО+1) * 5
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Величина задержки задаётся через регистровые параметры:
;.def 	TEMP1	; = LowByte
;.def	TEMP2	; = MedByte
;.def	TEMP3	; = HighByte


; Величина задержки задаётся константно, через макроопределения:
;.EQU	FORCE_LOAD_CONSTANT_DELAY = 1	; Раскомментировать...
;		.equ 	LowByte  = 255	; И задать константу...
;		.equ	MedByte  = 255	; 
;		.equ	HighByte = 1

;----- Code 


CPU_DUMB_DELAY:
	.ifdef FORCE_LOAD_CONSTANT_DELAY
		LDI	temp1,	LowByte		; Грузим три байта
		LDI	temp2,	MedByte		; Нашей выдержки
		LDI	temp3,	HighByte
	.endif

	LOOP__CPU_DUMB_DELAY:
		SUBI	temp1,	1		; Вычитаем 1			(1 такт CPU)
		SBCI	temp2,	0		; Вычитаем только С		(1 такт CPU)
		SBCI	temp3,	0		; Вычитаем только С		(1 такт CPU)
		BRCC	LOOP__CPU_DUMB_DELAY	; Если нет переноса - переход	(2 такта CPU)

		RET



;---------------------------------------------------------------------------
;
; Процедура: "Сбросить Timer/Counter0 (счётчик и предделитель)"
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Без параметров.

; Памятка: также использует/портит содержимое регистра TEMP.

;----- Code

RESET_TIMER0:
		SETB	GTCCR,	TSM	; Synchronization Mode ON
		SETB	GTCCR,	PSR0	; Prescaler Reset Request
		OUTI	TCNT0,	0	; Обнуляем счётный регистр
		CLRB	GTCCR,	TSM	; GO! (When the TSM bit is written to zero, the PSR0 bit is cleared by hardware, and the timer/counter start counting.)
		RET




;=== END "proclib.inc" =====================================================
; coded by (c) Celeron, 2013 @ http://we.easyelectronics.ru/my/Celeron/
.ENDIF
